"""Event types for the backtesting engine.

Uses msgspec.Struct for high-performance serialization and minimal memory footprint.
All events are immutable (frozen=True) to prevent accidental modification.
"""

from datetime import datetime
from enum import Enum, auto
from typing import Self

import msgspec


class EventType(Enum):
    """Types of events in the backtesting system."""

    MARKET = auto()
    SIGNAL = auto()
    ORDER = auto()
    FILL = auto()


class SignalType(Enum):
    """Direction of a trading signal."""

    LONG = auto()
    SHORT = auto()
    EXIT = auto()


class OrderSide(Enum):
    """Side of an order (buy or sell)."""

    BUY = auto()
    SELL = auto()


class MarketEvent(msgspec.Struct, frozen=True, array_like=True):
    """Represents a single bar of market data.

    Attributes:
        timestamp: The datetime of the bar
        ticker: The stock ticker symbol
        open: Opening price
        high: Highest price during the bar
        low: Lowest price during the bar
        close: Closing price
        volume: Trading volume
        adj_close: Adjusted closing price (for dividends/splits)
    """

    timestamp: datetime
    ticker: str
    open: float
    high: float
    low: float
    close: float
    volume: int
    adj_close: float | None = None

    @property
    def event_type(self) -> EventType:
        return EventType.MARKET

    def with_adjusted_prices(self, adjustment_factor: float) -> Self:
        """Return a new MarketEvent with prices adjusted by the given factor."""
        return MarketEvent(
            timestamp=self.timestamp,
            ticker=self.ticker,
            open=self.open * adjustment_factor,
            high=self.high * adjustment_factor,
            low=self.low * adjustment_factor,
            close=self.close * adjustment_factor,
            volume=self.volume,
            adj_close=self.adj_close,
        )


class SignalEvent(msgspec.Struct, frozen=True, array_like=True):
    """Represents a trading signal generated by a strategy.

    Attributes:
        timestamp: When the signal was generated
        ticker: The stock ticker symbol
        signal_type: LONG, SHORT, or EXIT
        strength: Signal strength/confidence (0.0 to 1.0)
        strategy_id: Identifier of the strategy that generated this signal
    """

    timestamp: datetime
    ticker: str
    signal_type: SignalType
    strength: float = 1.0
    strategy_id: str = "default"

    @property
    def event_type(self) -> EventType:
        return EventType.SIGNAL

    def __post_init__(self) -> None:
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(f"Signal strength must be between 0.0 and 1.0, got {self.strength}")


class OrderEvent(msgspec.Struct, frozen=True, array_like=True):
    """Represents an order to be executed.

    Attributes:
        timestamp: When the order was created
        ticker: The stock ticker symbol
        side: BUY or SELL
        quantity: Number of shares
        order_id: Unique identifier for this order
        limit_price: Optional limit price (None for market orders)
    """

    timestamp: datetime
    ticker: str
    side: OrderSide
    quantity: int
    order_id: str
    limit_price: float | None = None

    @property
    def event_type(self) -> EventType:
        return EventType.ORDER

    @property
    def is_market_order(self) -> bool:
        return self.limit_price is None

    @property
    def is_limit_order(self) -> bool:
        return self.limit_price is not None


class FillEvent(msgspec.Struct, frozen=True, array_like=True):
    """Represents a filled order.

    Attributes:
        timestamp: When the fill occurred
        ticker: The stock ticker symbol
        side: BUY or SELL
        quantity: Number of shares filled
        fill_price: Price at which the order was filled
        commission: Commission paid for this fill
        order_id: The order ID that was filled
        slippage: Price slippage from the expected price
    """

    timestamp: datetime
    ticker: str
    side: OrderSide
    quantity: int
    fill_price: float
    commission: float
    order_id: str
    slippage: float = 0.0

    @property
    def event_type(self) -> EventType:
        return EventType.FILL

    @property
    def total_cost(self) -> float:
        """Total cost including commission."""
        base_cost = self.fill_price * self.quantity
        if self.side == OrderSide.BUY:
            return base_cost + self.commission
        return base_cost - self.commission

    @property
    def cost_basis(self) -> float:
        """Cost per share including commission."""
        return self.total_cost / self.quantity if self.quantity > 0 else 0.0
